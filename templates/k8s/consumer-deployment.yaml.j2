apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ consumer_deployment_name }}
  namespace: {{ k8s_namespace }}
  labels:
    app: consumer
spec:
  replicas: {{ consumer_replicas }}
  selector:
    matchLabels:
      app: consumer
  template:
    metadata:
      labels:
        app: consumer
    spec:
      containers:
        - name: consumer
          image: {{ registry }}/consumer:{{ image_tag }}
          imagePullPolicy: Always
          env:
            - name: KAFKA_BOOTSTRAP
              value: "{{ kafka_bootstrap }}"
            - name: KAFKA_TOPICS
              value: "{{ consumer_topics | join(',') }}"
            - name: FLASK_URL
              value: "{{ flask_service_internal_url }}"
            - name: POST_TIMEOUT
              value: "{{ consumer_post_timeout }}"
            - name: POST_BACKOFF_SEC
              value: "{{ consumer_post_backoff }}"
            - name: KAFKA_GROUP_ID
              value: "{{ consumer_group_id }}"

            # ??? Add these for PA2 (f): pattern matching, batching, and scaling
            - name: KAFKA_TOPIC_PATTERN
              value: "^(?:sensors|weather|airquality|power|weather\\.|air\\.|water\\.|light\\.|sys\\.)"
              # Match shared pipeline topics plus any namespace fan-out by prefix
            - name: KAFKA_AUTO_OFFSET_RESET
              value: "latest"
            - name: KAFKA_INSTANCE_ID
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
              # Unique consumer identity (lets K8s replicas join same group)
            - name: POST_BATCH_SIZE
              value: "20"
              # Number of messages to batch per POST (useful for scaling)
            - name: FLASK_URL_BULK
              value: "http://{{ flask_service_name }}.{{ k8s_namespace }}.svc.cluster.local:{{ flask_container_port }}/bulk_update"
              # Optional: If you extend Flask to handle bulk inserts later
